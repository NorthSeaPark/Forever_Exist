# 《发明者量化平台笔记》



## CTA之趋势跟踪策略

Commodity Trading Adviosr

1.1 CTA策略主要以分钟，小时和日线等数据为主

1.2 趋势策略：利用一些技术指标守在趋势发生的必经之路上，买入并持有到趋势消失。通常叠加多个交易品种，或者利用策略多样性来降低风险。

1.3 反转策略：低买高卖。当股市在一个价格范围上下波动，反转策略就很适合。反转策略可以在两个相同品种的差价上套利交易，又利用价格网格进行低买高卖。



## MACD

利用短期指数移动平均线和长期指数移动平均线之间的聚合与分离的状况，来判断市场的状态
$$
DIF = EMA12 - EMA26
$$

$$
DEA = XAverage(DIF,9)
$$

- DIF大于0表示上涨，小于0表示下跌。或者，DIF向上突破DEA，形成买入信号。

- 当越来越多的人使用MACD，它就会失效，当人们选择放弃它，它又会变得有效。

### 来写一个策略：

DIF大于DEA ： 多头开仓/空头平仓

DIF小于DEA： 多头平仓/空头开仓

```python
mp = 0 #定义一个全局变量，用于控制虚拟持仓
#程序主函数
def onTick():
    _C(exchange.SetContractType,"rb000") #订阅期货品种
    bar = _C(exchange.GetRecords) #获取K线数据
    if len(bar) < 100: #K线数组长度太小就返回
        return
    macd = TA.MACD(bar, 5, 50, 15) #计算MACD数值
    dif = macd[0][-2]
    dea = macd[1][-2]
    last_close = bar[-1]['Close'] #获取卖价的最新价格
    global mp #全局变量，用于控制虚拟持仓
   	
    #如果持有多单，且dif<dea
    #停止买入，平多单，变空仓
    if mp == 1 and dif < dea: #如果有多单且dif<dea
        exchange.SetDirection("closebuy") #设置交易方向和类型，停止买入
        exchange.Sell(last_close - 1, 1) #平多单
        mp = 0 #仓位为空仓
        
    #如果持有空单，且dif>dea
    #停止卖出，平空单，变空仓
    if mp == -1 and dif > dea: #如果有空单，且dif>dea
        exchange.SetDirection("closesell")
        exchange.Buy(last_close, 1) #平空单
        mp = 0 #空仓
        
    #如果仓位为空，且dif>dea
    #开多单
    if mp == 0 and dif > dea:
        exchange.SetDirection("buy") 
        exchange.Buy(last_close, 1) #开多单
        mp = 1 #有多单
        
    #如果仓位为空，且dif<dea
    #开空单
    if mp == 0 and dif < dea:
        exchange.SetDirection("sell")
        exchange.Sell(last_close - 1, 1) #开空单
        mp = -1 #有空单
def main():
    while True:
        onTick()
        Sleep(1000)
```



## ADX平均趋向指数

ADX不能判断多空方向，只能衡量趋势的强弱。

计算ADX的数值：

up - 正向移动距离	down - 负向移动距离	+DI - 用波动率修正后的上涨趋势

-DI - 用波动率修正后的下降趋势	DX - 会随着趋势的强弱指示在0-100之间

ADX - 是DX的14天平均线

在震荡的情形下，MACD预测的会很不准，我们需要加入ADX来控制震荡时期的回撤幅度

修改后的策略：

- **多头开仓： DIF 大于 DEA， 并且 ADX 上升**
- **空头开仓： DIF 小于 DEA， 并且 ADX 上升**
- **多头平仓： DIF 小于 DEA， 或者 ADX  下降**
- **空头平仓： DIF 大于 DEA， 或者 ADX 下降**  

代码

```python
# 导入库
import talib
import numpy as np
mp = 0 # 定义一个全局变量， 用于控制虚拟持仓
# 把 K 线数组转换成最高价、 最低价、 收盘价数组
# 用于转换为 numpy.array 类型数据
def get_data(bars):
arr = [[], [], []]
for i in bars:
	arr[0].append(i['High'])
	arr[1].append(i['Low'])
	arr[2].append(i['Close'])
return arr
# 程序主函数
def onTick():
	_C(exchange.SetContractType, "rb000") # 订阅期货品种
	bar = _C(exchange.GetRecords) # 获取 K 线数组
	if len(bar) < 100: # 如果 K 线数组长度太小就返回
		return
	macd = TA.MACD(bar, 5, 50, 15) # 计算 MACD 值
	dif = macd[0][-2] # 获取 DIF 的值， 返回一个数组
	dea = macd[1][-2] # 获取 DEA 的值， 返回一个数组
	np_arr = np.array(get_data(bar)) # 把列表转换为numpy.array类型数据
	adx_arr = talib.ADX(np_arr[0], np_arr[1], np_arr[2], 14) # 计算 ADX 的值
	adx1 = adx_arr[-2] # 倒数第二根 K 线的 ADX 值
	adx2 = adx_arr[-3] # 倒数第三根 K 线的 ADX 值
	last_close = bar[-1]['Close'] # 获取最新价格（卖价）
	global mp # 全局变量， 用于控制虚拟持仓
	if mp == 1 and (dif < dea or adx1 < adx2):
		exchange.SetDirection("closebuy") # 设置交易方向和类型
		exchange.Sell(last_close - 1, 1) # 平多单
		mp = 0 # 设置虚拟持仓的值， 即空仓
	if mp == -1 and (dif > dea or adx1 < adx2):
		exchange.SetDirection("closesell") # 设置交易方向和类型
		exchange.Buy(last_close, 1) # 平空单
		mp = 0 # 设置虚拟持仓的值， 即空仓
	if mp == 0 and dif > dea and adx1 > adx2:
		exchange.SetDirection("buy") # 设置交易方向和类型
		exchange.Buy(last_close, 1) # 开多单
		mp = 1 # 设置虚拟持仓的值， 即有多单
	if mp == 0 and dif < dea and adx1 > adx2:
		exchange.SetDirection("sell") # 设置交易方向和类型
		exchange.Sell(last_close - 1, 1) # 开空单
		mp = -1 # 设置虚拟持仓的值， 即有空单
def main():
	while True:
	onTick()
	Sleep(1000)
```

